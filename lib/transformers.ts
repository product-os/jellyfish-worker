import { getLogger } from '@balena/jellyfish-logger';
import type { LogContext } from '@balena/jellyfish-logger';
import type { JsonSchema } from '@balena/jellyfish-types';
import type { Contract } from '@balena/jellyfish-types/build/core';
import _ from 'lodash';
import * as skhema from 'skhema';
import { v4 as uuidv4 } from 'uuid';
import type { ProducerResults } from './queue';
import type { EnqueueOptions, TransformerContract } from './types';

const logger = getLogger('worker');

export interface EvaluateOptions {
	transformers: TransformerContract[];
	oldContract: Contract<any> | null;
	newContract: Contract<any>;
	logContext: LogContext;
	query: (
		schema: JsonSchema,
		opts: { sortBy?: string; sortDir?: 'asc' | 'desc'; limit?: number },
	) => Promise<Contract[]>;
	// TS-TODO: Make slug optional in core model
	executeAndAwaitAction: (
		actionRequest: EnqueueOptions,
	) => Promise<ProducerResults>;
}

// TS-TODO: Transformers should be a default model and included in this module
export const evaluate = async ({
	transformers,
	oldContract,
	newContract,
	logContext,
	query,
	executeAndAwaitAction,
}: EvaluateOptions): Promise<null> => {
	if (!transformers || !Array.isArray(transformers)) {
		logger.info(logContext, 'No transformers');
		return null;
	} else {
		logger.info(logContext, 'Transformers found', {
			count: transformers.length,
		});
	}

	// Only run transformers with contracts with a valid artifact or which do not have artifacts at all
	// and their input filter matches now, but didn't match before (or artifact wasn't ready)
	const readyNow = newContract.data?.$transformer?.artifactReady;
	if (readyNow === false) {
		logger.info(logContext, 'readyNow is false', {
			newContract: newContract.id,
		});
		return null;
	}
	const artifactReadyChanged =
		oldContract?.data?.$transformer?.artifactReady !== readyNow;

	await Promise.all(
		transformers.map(async (transformer: TransformerContract) => {
			if (!transformer.data.inputFilter) {
				logger.info(logContext, 'Transformer has no inputFilter defined', {
					transformer: transformer.id,
				});
				return;
			}
			// TODO: Allow transformer input filter to match $$links, by re-using the trigger filter
			const matchesNow = skhema.isValid(
				transformer.data.inputFilter,
				newContract,
			);
			const matchedPreviously = skhema.isValid(
				transformer.data.inputFilter,
				oldContract || {},
			);

			const shouldRun =
				matchesNow && (!matchedPreviously || artifactReadyChanged);

			if (!shouldRun) {
				logger.info(logContext, 'Transformer shouldRun is false', {
					transformer: transformer.id,
					matchesNow,
					matchedPreviously,
					artifactReadyChanged,
				});
				return;
			}

			const transformerActor = await getTransformerActor(query, transformer);
			if (!transformerActor) {
				logger.warn(
					logContext,
					'Cannot run transformer that does not have an owner',
					{
						transformerId: transformer.id,
						transformerSlug: transformer.slug,
					},
				);
				return;
			}

			// Re enqueue an action request to call the matchmaking function
			// TODO: link task to origin transformer
			logger.info(logContext, 'Creating transformer task', {
				transformer: transformer.id,
				actor: transformerActor.id,
				newContract: newContract.id,
			});
			const result: any = await executeAndAwaitAction({
				card: 'task@1.0.0',
				type: 'type',
				action: 'action-create-card@1.0.0',
				actor: transformerActor.id,
				arguments: {
					reason: null,
					properties: {
						name: `Transform ${newContract.name} using transformer ${transformer.name}`,
						data: {
							status: 'pending',
							input: newContract,
							transformer,
							actor: transformerActor.id,
							workerFilter: {
								schema: transformer.data.workerFilter,
							},
						},
					},
				},
			});

			// TODO: Improve core API for linking contracts
			await executeAndAwaitAction({
				card: 'link@1.0.0',
				type: 'type',
				action: 'action-create-card@1.0.0',
				actor: transformerActor.id,
				arguments: {
					reason: null,
					properties: {
						slug: `link-${transformer.id}-generated-${
							result.data.id
						}-${uuidv4()}`,
						name: 'generated',
						data: {
							inverseName: 'was generated by',
							from: {
								id: transformer.id,
								type: transformer.type,
							},
							to: {
								id: result.data.id,
								type: result.data.type,
							},
						},
					},
				},
			});
		}),
	);
	return null;
};

async function getTransformerActor(
	query: (
		schema: any,
		opts: {
			sortBy?: string;
			sortDir?: 'asc' | 'desc';
			limit?: number;
		},
	) => Promise<Contract[]>,
	transformer: TransformerContract,
) {
	// The transformer should be run on behalf of the actor that owns the
	// transformer
	const [transformerOwner] = await query(
		{
			type: 'object',
			properties: {
				active: {
					const: true,
				},
			},
			$$links: {
				owns: {
					type: 'object',
					properties: {
						id: {
							const: transformer.id,
						},
					},
				},
			},
		},
		{
			limit: 1,
		},
	);

	if (transformerOwner) {
		return transformerOwner;
	}

	// Or by the actor that owns its contract-repository
	const [repoOwner] = await query(
		{
			type: 'object',
			properties: {
				active: {
					const: true,
				},
			},
			$$links: {
				owns: {
					type: 'object',
					required: ['type', 'data'],
					properties: {
						type: {
							const: 'contract-repository@1.0.0',
						},
						active: {
							const: true,
						},
						data: {
							type: 'object',
							required: ['base_slug'],
							properties: {
								base_slug: {
									const: transformer.slug,
								},
							},
						},
					},
				},
			},
		},
		{
			limit: 1,
		},
	);
	return repoOwner;
}
